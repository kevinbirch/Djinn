module: Prelude;

// Arithmetic symbols

@description: addition;
+ :: [number number] -> [number]

\[+ add]

@description: subtraction;
@sealed: true;
- :: [number number] -> [number]

\[- sub]

@description: multiplication;
@sealed: true;
* :: [number number] -> [number]

\[* mul]

@description: division;
@sealed: true;
/ :: [number number] -> [number]

\[/ div]

// Comparison symbols

@description: compares the top two elements of the stack for equality;
@sealed: true;
== :: [a b] -> [bool]

\[== eq]

@description: compares the top two elements of the stack for inequality;
@sealed: true;
!= :: [a b] -> [bool]

\[!= ne]

@description: compares the top two elements of the stack, pushes true if the top is greater than then second;
@sealed: true;
> :: [a b] -> [bool]

\[> gt]

@description: compares the top two elements of the stack, pushes true if the top is less than the second;
@sealed: true;
< :: [a b] -> [bool]

\[< lt]

@description: compares the top two elements of the stack, pushes true if the top is greater than or equal to the second;
@sealed: true;
>= :: [a b] -> [bool]

\[>= gte]

@description: compares the top two elements of the stack, pushes true if the top is less than or equal to the second;
@sealed: true;
<= :: [a b] -> [bool]

\[<= lte]

// Stack manipulation functions

@description: swaps the second and third items on the stack;
swip :: [a b c] -> [b a c]

\[swip [swap] dip]

@description: moves the third item to the top of the stack;
dig :: [a b c] -> [b c a]

\[dig swip swap]

@description: moves the fourth item to the top of the stack;
dig4 :: [a b c d] -> [b c d a]

\[dig4 [dig] dip swap]

@description: moves the fifth item to the top of the stack;
dig5 :: [a b c d e] -> [b c d e a]

\[dig5 [dig4] dip swap]

// Conditional functions

@description: executes the lambda at the second element if the boolean at the top of the stack is true;
if :: A [(A -> B) bool] -> B

\[if [id]? drop apply]

@description: executes the lambda at the second element if the boolean at the top of the stack is true, otherwise execute the lambda at the third element;
ifel :: A [(A -> B) (A -> B) bool] -> B

\[ifel [id]? drop [drop] dip apply]
\[ifel drop drop apply]

